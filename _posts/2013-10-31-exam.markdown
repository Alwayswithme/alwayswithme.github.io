---
layout: post
title: "Exam About Skybility"
date: 2013-10-31 00:08:00
published: false
categories: jekyll update
---

今天有幸参加傲冠软件的上机测试,抱着先运行再重构后优化的原则写了不少  
Ugly and Clumsy Code. 最后一题,老师给了我提示都没有做出来,感觉很懊恼!

- 第一题:检测密码是否合法
要求长度在8~16之间,包含至少三种字符
{% highlight java %}
import java.util.Scanner;

import org.junit.Test;

public class ValidatePassword {
  private static Scanner in;
  private static final String FORMATTER = ".*%s.*";
  public static void main(String[] args) {
    in = new Scanner(System.in);
    String input = in.nextLine();
    checkPassword(input);
  }
  static void checkPassword(String input) {
    int length = input.length();
    if (length >= 8 && length <= 16 && count(input) >= 3)
      System.out.println("=> Password is valid");
    else
      System.out.println("=> Password is not valid");
  }
  private static int count(String input) {
    int count = 0;
    String[] regexs = 
      "[a-z] [A-Z] [0-9] [~!@#$%^]".split(" ");
    for(String regex: regexs)     //根据给定的正则数组遍历,符合则计数加一
      count = input.matches(String.format(FORMATTER, regex)) ? count+1 : count;
    return count;
  }
  
  /*
   * Test case make sure the output will be 
   * => Password is not valid 
   * => Password is not valid 
   * => Password is valid 
   * => Password is valid 
   * => Password is not valid 
   * => Password is not valid
   */
  @Test
  public void test() {
    String[] input = new String[6];
    input[0] = "absA1~";                // less than 8
    input[1] = "ASDQWEasdqwe123~!@$%^"; // great than 16
    input[2] = "asAS12!@";      // contains four different char
    input[3] = "asdASd1223";    // contains three different char
    input[4] = "asdasaa1223";   // contains two different char
    input[5] = "helloworld";    // contains one char
    for (String i: input) {
      checkPassword(i);
    }
  }
}
{% endhighlight %}

- 第二题:根据最大公约数和最小公倍数求可能的组合  
思路:组合的数字必然在gcd和lcm之间,嵌套循环遍历求出
{% highlight java %}
import java.util.Scanner;

public class CalCombination {
  private static Scanner in;
  public static void main(String[] args) {
    int gcd, lcm;
    in = new Scanner(System.in);
    System.out.println("=> Please input a gcd");
    gcd = in.nextInt();
    System.out.println("=> Please input a lcm");
    lcm = in.nextInt();

    combination(gcd, lcm);
  }
  /**
   * 根据gcd和lcm计算组合的函数
   */
  static void combination(int gcd, int lcm) {
    int mulResult = gcd * lcm;
    for (int x = gcd; x <= lcm; x++)
      //第二个循环条件多点约束,提前跳出循环,减少不必要的判断
      for (int y = gcd; y != lcm && x*y > mulResult; y++)
        //符合(唯一分解并且最大公约数和输入相等) 条件的x,y输出
        if (x * y == mulResult && gcd(x,y) == gcd)
          System.out.printf("x is %4d,  y is %4d\n", x, y);
  }
  /**
   * 辗转相除算法
   */
  public static long gcd(long m, long n) {
    while(n != 0) {
      long rem = m % n;
      m = n;
      n = rem;
    }
    return m;
  }
}

{% endhighlight %}

- 第三题:生产者消费者,只记得jdk5.0后可以加锁却忘了synchronized
以下用Lock版本实现
{% highlight java %}
import java.util.LinkedList;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

public class ConsumerAndProducer {
  private LinkedList<String> queue = new LinkedList<String>();
  private final ReentrantLock lock = new ReentrantLock();
  private final Condition empty = lock.newCondition();

  public static void main(String[] args) throws InterruptedException {
    ConsumerAndProducer cap = new ConsumerAndProducer();
    cap.start();
    System.out.println("main exist");
  }

  public static void sleepOneSec() {
    try {
      Thread.sleep(1000);
    }catch (InterruptedException e) {
      e.printStackTrace();
    }
  }
  public void start() throws InterruptedException {
    /* 使用匿名内部类创建两个线程 */
    Thread producer = new Thread(new Runnable(){
        @Override
        public void run() {
          for(int i = 0; i < 30; i++) {
            sleepOneSec();
            lock.lock();
            try{
              String temp = String.valueOf((int)(Math.random()*100));
              queue.addLast(temp);
              empty.signal();       //生产者通知消费
              System.out.println("producer add integer: " + temp);
            } finally {
              lock.unlock();
            }
          }
          queue.addLast("bye");
        }
    });
    Thread consumer = new Thread(new Runnable(){
        @Override
        public void run() {
          for(;;) {
            sleepOneSec();
            lock.lock();
            try {
              while(queue.size() == 0)
                empty.await();    //消费者等待生产
              String item = queue.removeFirst();
              System.out.println("consumer get integer form producer: " + item);
              if ("bye".equals(item))
                break;
            } catch(InterruptedException e) {
              e.printStackTrace();
            }finally {
              lock.unlock();
            }
          }
        }
    });
    consumer.start();
    producer.start();
    //启动两个线程,并让主线程等待消费者进程退出
    consumer.join();
  }
}
{% endhighlight %}
